# 課題1　 パズル問題の定式化

## 概要

この課題では，パズル問題を1つ選択し，その定式化およびソルバーを用いた解の導出を行う．ここでは，ボンバーパズル（≒ [マインスイーパ](https://en.wikipedia.org/wiki/Minesweeper_(video_game)) ）を選択した．

## ルール

ボンバーパズルとは，ランダムに爆弾が配置されている盤面の爆弾の位置を特定するパズルである．ここで，いくつかのマスに対しては周囲の爆弾の数を表す数字が予め与えられている．また，数字が書いてあるマス目には爆弾がないことが保証されている．このとき，爆弾の位置を決定するのがボンバーパズルのルールである．

![ボンバーパズルのイメージ図](./draft/fig/bomber_puzzle.svg)

## 変数の定義．

正の整数 $n$ を1辺のマス目の数とし，$(n + 2)\times (n + 2)$ の盤面 $A$ を考える．

また，$0\leq i,j < n+2$ を満たす整数 $i,j$ を用いて，盤面の上から $i$ 番目，左から $j$ 番目のマスを $A(i, j)$ と表すことにする．また，マス $A(i,j)$ に書かれている数字を $B(i,j)$ と表すことにする．ここで，数字が書かれていないマスは便宜上 **0と書かれている** （つまり $B({i,j})=0$）と考える．

さらに，（数字の大小に関わらず）数字が記述されているマス全体の集合を $S$ とする．すなわち，

$$
S = \{A(i_n,j_n)|A(i_n,j_n)>0\}
$$

と表すことができる．

そして，マス $A(i,j)$ に爆弾がある場合は $A(i, j) = 1$，そうでない場合は $A(i, j) = 0$ とする．
## 定式化

上記の変数の定義に従って，ボンバーパズルの定式化を行う．
### 制約条件

盤面 $A$，集合 $S$ に対して，

$$
\forall A(i_n, j_n) \in S;\quad A(i_n, j_n) = 0 \\
\forall A(i_n, j_n) \in S;\quad \sum_{k=-1}^1\sum_{l=-1}^{1}A(i_{n+k},j_{n+l})=B(i_n,j_n)\\
$$

### 目的関数

この問題は制約条件を満たす実行可能解が存在するかを判別すればよい．すなわち目的関数は例えば

$$
\text{minimize}\,  1
$$

とでもしておけば良い．

## 解の導出

この最適化問題は，「実行可能解が少なくとも1つ存在する」か否かを判定する問題と考えることができる．つまり，実行可能解が1つでも存在すればボンバーパズルは解くことができ，実行可能解が存在しない場合は解くことができない．

## 実装

ここでは，Pythonおよびgurobiを用いて，最適化問題を解くプログラムを実装する．

## 実行方法

gurobi のライセンスの取得を行い，gurobipy の動作するPython環境を用意する．テストモジュールを実行するために，ターミナル上で

```
% git clone https://github.com/Okabe-Junya/MajorExperimentsA
% python3 ./MajorExperimentsA/task1/src/test.py
```

を実行する．`assertion error` や標準エラーががでないことを確認した上で，


```
% python3 ./MajorExperimentsA/task1/src/main.py sys.argv[1]
```

を実行する．これにより実行可能解が存在するか否かを判定する．ただし，`sys.argv[1]` には盤面の大きさを指定する．